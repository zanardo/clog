#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

import sys, os, os.path, subprocess, uuid, time, json, platform
import getpass, argparse, urllib, urllib2

def strenc(s, encoding='UTF-8'):
	return s.decode(encoding, 'replace').encode('utf-8')

def gethome():
	return os.path.expanduser('~')

def getscriptspath():
	return os.path.join(gethome(), '.clog-scripts')

def getqueuepath():
	return os.path.join(gethome(), '.clog-queue')

def createpaths():
	paths = [ getscriptspath(), getqueuepath() ]
	for p in paths:
		if not os.path.isdir(p):
			print("creating {}...").format(p)
			os.mkdir(p, 0700)

def runscript(script, encoding='UTF-8'):
	print("running script {}").format(script)
	sp = os.path.join(getscriptspath(), script)
	if not os.path.isfile(sp):
		print("error: file {} not found!").format(sp)
		sys.exit(1)
	rid = str(uuid.uuid4())
	qlp = os.path.join(getqueuepath(), "{}.out".format(rid))
	with open(qlp, "w") as fp:
		st = time.time()
		s = subprocess.Popen(sp, stderr=subprocess.STDOUT, bufsize=4096,
			stdout=subprocess.PIPE)
		ret = None
		while True:
			chunk = strenc(s.stdout.read(4096), encoding=encoding)
			fp.write(chunk)
			ret = s.poll()
			if ret is not None:
				break
		et = time.time()
	qcp = os.path.join(getqueuepath(), rid)
	with open(qcp + ".tmp", "w") as fp:
		json.dump(dict(start_time=st, end_time=et,
			status='OK' if ret == 0 else 'FAIL', script=script,
			computername=strenc(platform.node()),
			username=strenc(getpass.getuser())), fp)
	os.rename(qcp + '.tmp', qcp + '.meta')
	print("finished with id={}").format(rid)
	return rid

def runqueue(server, timeout=30):
	print("starting queue dispatch...")
	qp = getqueuepath()
	os.chdir(qp)
	for f in os.listdir('.'):
		if len(f) == 41 and f.endswith('.meta'):
			rid = f[:36]
			print("sending job {}...").format(rid)
			with open(f, 'r') as fp:
				meta = json.load(fp)
			with open(rid + '.out', 'r') as fp:
				meta['output'] = fp.read()
			meta['id'] = rid
			data = urllib.urlencode(meta)
			req = urllib2.Request(server, data)
			req.addheaders = [('Content-Type', 'text/plain; charset=utf-8')]
			try:
				res = urllib2.urlopen(req, None, timeout=timeout).read()
			except urllib2.URLError, ex:
				print("error: {}").format(ex)
			else:
				if res == 'ok':
					os.unlink("{}.out".format(rid))
					os.unlink("{}.meta".format(rid))
				else:
					print res
	print("finished queue dispatch")

if __name__ == '__main__':

	parser = argparse.ArgumentParser()
	subparsers = parser.add_subparsers(help='sub-commands help', dest='sub')

	parser_run = subparsers.add_parser('run', help='run scripts')
	parser_run.add_argument('-e', '--encoding', 
		help='charset for script output (default: UTF-8)', default='UTF-8')
	parser_run.add_argument('script', help='script name')

	parser_queue = subparsers.add_parser('send-queue', help='send scripts output')
	parser_queue.add_argument('server_url', help='server url')
	parser_queue.add_argument('-t', '--timeout', help='timeout in seconds',
		default=30, type=int)

	args = parser.parse_args()
	
	if args.sub == 'run':
		runscript(args.script, encoding=args.encoding)
	elif args.sub == 'send-queue':
		runqueue(args.server_url, timeout=args.timeout)