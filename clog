#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
#
# Copyright (c) 2013, J. A. Zanardo Jr. <zanardo@gmail.com>
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# This is clog client. See https://github.com/zanardo/clog for more details.
#

import sys, os, os.path, subprocess, uuid, time, json, platform
import getpass, argparse, urllib, urllib2

def strenc(s, encoding='UTF-8'):
	return s.decode(encoding, 'replace').encode('utf-8')

def gethome():
	return os.path.expanduser('~')

def getscriptspath():
	return os.path.join(gethome(), '.clog-scripts')

def getqueuepath():
	return os.path.join(gethome(), '.clog-queue')

def createpaths(queue_path=None, scripts_path=None):
	if queue_path is None: queue_path = getqueuepath()
	if scripts_path is None: scripts_path = getscriptspath()
	paths = [ queue_path, scripts_path ]
	for p in paths:
		if not os.path.isdir(p):
			print("creating {}...").format(p)
			os.mkdir(p, 0700)

def runscript(script, encoding='UTF-8', scripts_path=None, queue_path=None):
	print("running script {}").format(script)
	sp = os.path.join(scripts_path, script)
	if not os.path.isfile(sp):
		print("error: file {} not found!").format(sp)
		sys.exit(1)
	rid = str(uuid.uuid4())
	qlp = os.path.join(queue_path, "{}.out".format(rid))
	with open(qlp, "w") as fp:
		st = time.time()
		s = subprocess.Popen(sp, stderr=subprocess.STDOUT, bufsize=4096,
			stdout=subprocess.PIPE)
		ret = None
		while True:
			chunk = strenc(s.stdout.read(4096), encoding=encoding)
			fp.write(chunk)
			ret = s.poll()
			if ret is not None:
				break
		et = time.time()
	qcp = os.path.join(queue_path, rid)
	with open(qcp + ".tmp", "w") as fp:
		json.dump(dict(start_time=st, end_time=et,
			status='OK' if ret == 0 else 'FAIL', script=script,
			computername=strenc(platform.node()),
			username=strenc(getpass.getuser())), fp)
	os.rename(qcp + '.tmp', qcp + '.meta')
	print("finished with id={}").format(rid)
	return rid

def runqueue(server, timeout=30, queue_path=None):
	print("starting queue dispatch...")
	os.chdir(queue_path)
	for f in os.listdir('.'):
		if len(f) == 41 and f.endswith('.meta'):
			rid = f[:36]
			print("sending job {}...").format(rid)
			with open(f, 'r') as fp:
				meta = json.load(fp)
			with open(rid + '.out', 'r') as fp:
				meta['output'] = fp.read()
			meta['id'] = rid
			data = urllib.urlencode(meta)
			req = urllib2.Request(server, data)
			req.addheaders = [('Content-Type', 'text/plain; charset=utf-8')]
			try:
				res = urllib2.urlopen(req, None, timeout=timeout).read()
			except urllib2.URLError, ex:
				print("error: {}").format(ex)
			else:
				if res == 'ok':
					os.unlink("{}.out".format(rid))
					os.unlink("{}.meta".format(rid))
				else:
					print res
	print("finished queue dispatch")

if __name__ == '__main__':

	parser = argparse.ArgumentParser()
	parser.add_argument('-q', '--queue-path',
		help='queue path (default: $HOME/.clog-queue', default=getqueuepath(),
		dest='queue_path')
	parser.add_argument('-s', '--scripts-path',
		help='scripts path (default: $HOME/.clog-scripts',
		default=getscriptspath(), dest='scripts_path')

	subparsers = parser.add_subparsers(help='sub-commands help', dest='sub')

	parser_run = subparsers.add_parser('run', help='run scripts')
	parser_run.add_argument('-e', '--encoding', 
		help='charset for script output (default: UTF-8)', default='UTF-8')
	parser_run.add_argument('script', help='script name')

	parser_queue = subparsers.add_parser('send-queue', help='send scripts output')
	parser_queue.add_argument('server_url', help='server url')
	parser_queue.add_argument('-t', '--timeout', help='timeout in seconds',
		default=30, type=int)

	args = parser.parse_args()

	createpaths(scripts_path=args.scripts_path, queue_path=args.queue_path)
	
	if args.sub == 'run':
		runscript(args.script, encoding=args.encoding, queue_path=args.queue_path,
			scripts_path=args.scripts_path)
	elif args.sub == 'send-queue':
		runqueue(args.server_url, timeout=args.timeout, queue_path=args.queue_path)