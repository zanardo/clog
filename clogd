#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
#
# Copyright (c) 2013, Antonio Zanardo <zanardo@gmail.com>
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# This is clog server. See https://github.com/zanardo/clog for more details.
#

__VERSION__ = '0.2dev'

from bottle import run, local, route, view, get, post, redirect, \
    response, request, static_file
from contextlib import contextmanager
from functools import wraps
from hashlib import sha1
from uuid import uuid4

import threading, sqlite3, os, re, datetime, os.path, argparse, logging, \
    random, bottle, time

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s.%(msecs)03d '
    '%(levelname)3s | %(message)s', datefmt='%Y/%m/%d %H:%M:%S')
log = logging.getLogger(__name__)

config = {}
config['dbname'] = 'clogd.db'

# Bottle has a low limit for post data. Let's make it larger.
bottle.BaseRequest.MEMFILE_MAX = 10 * 1024 * 1024

def getctx():
    return dict(version=__VERSION__, username=currentuser(),
        isadmin=userisadmin(currentuser()))

def getdb():
    # Return a database connection handle per thread
    if not hasattr(local, 'db'):
        local.db = sqlite3.connect(config['dbname'],
                                   detect_types=sqlite3.PARSE_DECLTYPES)
        # Access results via dict() by column name
        local.db.row_factory = sqlite3.Row
    return local.db

def getcursor():
    # Return a new cursor for database access
    return getdb().cursor()

@contextmanager
def db_trans():
    # Open a new database transaction and commit on context
    # exit, or rollback in case anything fails.
    dbh = getdb()
    c = dbh.cursor()
    try:
        yield c     # New cursor
    except:
        dbh.rollback()
        raise
    finally:
        dbh.commit()

def timestamp_to_show(timestamp):
    if timestamp:
        return datetime.datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')
    else:
        return '-'

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        session_id = request.get_cookie('clog')
        if not session_id or not validatesession(session_id):
            return redirect('/login')
        return f(*args, **kwargs)
    return decorated

def requires_admin(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        session_id = request.get_cookie('clog')
        if not session_id or not validatesession(session_id) or \
                not userisadmin(currentuser()):
            return 'not authorized'
        return f(*args, **kwargs)
    return decorated

def validateuserdb(user, passwd):
    passwdsha1 = sha1(passwd).hexdigest()
    c = getcursor()
    c.execute("select username from users where username = :user "
        "and password = :passwdsha1", locals())
    r = c.fetchone()
    return bool(r)

def validatesession(session_id):
    c = getcursor()
    c.execute("select session_id from sessions where session_id = :session_id",
        locals())
    r = c.fetchone()
    return bool(r)

def currentuser():
    session_id = request.get_cookie('clog')
    c = getcursor()
    c.execute("select username from sessions "
        "where session_id = :session_id", locals())
    return c.fetchone()['username']

def userisadmin(username):
    c = getcursor()
    c.execute("select is_admin from users where username = :username",
        locals())
    return c.fetchone()['is_admin']

def removesession(session_id):
    with db_trans() as c:
        c.execute("delete from sessions where session_id = :session_id", 
            locals())

def makesession(user):
    with db_trans() as c:
        session_id = str(uuid4())
        c.execute("insert into sessions (session_id, username) "
            "values (:session_id, :user)", locals())
    return session_id

@get('/admin')
@view('admin')
@requires_auth
@requires_admin
def admin():
    c = getcursor()
    c.execute("select username, is_admin from users "
        "order by username")
    users = []
    for user in c:
        user = dict(user)
        users.append(user)
    return dict(ctx=getctx(), users=users)

@get('/admin/remove-user/:username')
@requires_auth
@requires_admin
def removeuser(username):
    if username == currentuser():
        return 'cant remove current user!'
    with db_trans() as c:
        c.execute("delete from users where username = :username", locals())
    return redirect('/admin')

@post('/admin/save-new-user')
@requires_auth
@requires_admin
def newuser():
    assert 'username' in request.forms
    username = request.forms.username
    if username.strip() == '':
        return 'invalid user!'
    password = str(int(random.random() * 999999))
    sha1password = sha1(password).hexdigest()
    with db_trans() as c:
        c.execute("insert into users (username, password, is_admin ) "
            "values (:username, :sha1password, 0)", locals())
    return u'user %s created with password %s' % ( username, password )

@get('/admin/force-new-password/:username')
@requires_auth
@requires_admin
def forceuserpassword(username):
    password = str(int(random.random() * 999999))
    sha1password = sha1(password).hexdigest()
    if username == currentuser():
        return 'cant change password for current user!'
    with db_trans() as c:
        c.execute("update users set password = :sha1password "
            "where username = :username", locals())
    return u'user %s had password changed to: %s' % ( username, password )

@get('/admin/change-user-admin-status/:username/:status')
@requires_auth
@requires_admin
def changeuseradminstatus(username, status):
    if username == currentuser():
        return 'cant change admin status for current user!'
    assert status in ( '0', '1' )
    with db_trans() as c:
        c.execute("update users set is_admin = :status "
            "where username = :username", locals())
    return redirect('/admin')

@get('/login')
@view('login')
def login():
    return dict(version=__VERSION__)

@post('/login')
def validatelogin():
    assert 'user' in request.forms
    assert 'passwd' in request.forms
    user = request.forms.user
    passwd = request.forms.passwd
    if validateuserdb(user, passwd):
        session_id = makesession(user)
        response.set_cookie('clog', session_id)
        return redirect('/')
    else:
        return 'invalid user or password'

@get('/logout')
def logout():
    session_id = request.get_cookie('clog')
    if session_id:
        removesession(session_id)
        response.delete_cookie('clog')
    return redirect('/login')

@get('/change-password')
@view('change-password')
@requires_auth
def changepassword():
    return dict(ctx=getctx())

@post('/change-password')
@requires_auth
def changepasswordsave():
    assert 'oldpasswd' in request.forms
    assert 'newpasswd' in request.forms
    assert 'newpasswd2' in request.forms
    oldpasswd = request.forms.oldpasswd
    newpasswd = request.forms.newpasswd
    newpasswd2 = request.forms.newpasswd2
    username = currentuser()
    if not validateuserdb(username, oldpasswd):
        return 'invalid current password!'
    if newpasswd.strip() == '' or newpasswd2.strip() == '':
        return 'invalid new password!'
    if newpasswd != newpasswd2:
        return 'new passwords do not match!'
    passwdsha1 = sha1(newpasswd).hexdigest()
    with db_trans() as c:
        c.execute("update users set password = :passwdsha1 "
            "where username = :username", locals())
    return redirect('/')

@route('/static/:filename')
def static(filename):
    assert re.match(r'^[\w\d\-]+\.[\w\d\-]+$', filename)
    return static_file('static/%s' % filename, root='.')

@get('/job/<id>')
@requires_auth
def joboutput(id):
    if not re.match(r'^[a-f0-9-]{36}$', id):
        raise ValueError('invalid id')
    output = ''
    with open(os.path.join('clogd.db.logs', id), 'r') as fp:
        output = fp.read()
    response.content_type = 'text/plain'
    return output

@get('/jobs/<computername>/<computeruser>/<script>/')
@view('history')
@requires_auth
def jobhistory(computername, computeruser, script):
    ctx = getctx()
    ctx['computername'] = computername
    ctx['computeruser'] = computeruser
    ctx['script'] = script
    c = getcursor()
    c.execute("select id, computername, computeruser, script, "
        "datestarted, datefinished, status, datefinished-datestarted as duration "
        "from jobhistory "
        "where computername=:computername "
        "  and computeruser=:computeruser "
        "  and script=:script "
        "order by computername, computeruser, script, datestarted desc", (locals()))
    history = []
    for hist in c:
        h = dict(hist)
        h['datestarted'] = timestamp_to_show(h['datestarted'])
        h['datefinished'] = timestamp_to_show(h['datefinished'])
        h['duration'] = "%.3f" % h['duration']
        history.append(h)
    return dict(history=history, ctx=ctx)

@get('/config-job/<computername>/<computeruser>/<script>/')
@view('config-job')
@requires_auth
@requires_admin
def configjob(computername, computeruser, script):
    ctx = getctx()
    ctx['computername'] = computername
    ctx['computeruser'] = computeruser
    ctx['script'] = script
    daystokeep = 30
    c = getcursor()
    c.execute('select daystokeep from jobconfig where '
        'computername=:computername and '
        'computeruser=:computeruser and '
        'script=:script', locals())
    r = c.fetchone()
    if r:
        daystokeep = r['daystokeep']
    return dict(ctx=ctx, daystokeep=daystokeep)

@post('/save-daystokeep/<computername>/<computeruser>/<script>/')
@requires_auth
@requires_admin
def savedaystokeep(computername, computeruser, script):
    assert 'daystokeep' in request.forms
    daystokeep = request.forms.daystokeep
    if not re.match(r'^\d+$', daystokeep):
        return 'invalid argument'
    daystokeep = int(daystokeep)
    if daystokeep < 1:
        return 'days to keep must be >= 1'
    c = getcursor()
    c.execute('select daystokeep from jobconfig where '
        'computername=:computername and '
        'computeruser=:computeruser and '
        'script=:script', locals())
    r = c.fetchone()
    if r:
        with db_trans() as c:
            c.execute('update jobconfig set daystokeep=:daystokeep '
                'where computername=:computername and '
                'computeruser=:computeruser and '
                'script=:script', locals())
    else:
        with db_trans() as c:
            c.execute('insert into jobconfig values ( '
                ':computername, :computeruser, :script, '
                ':daystokeep)', locals())
    return redirect('/config-job/' + computername + '/' + 
        computeruser + '/' + script + '/')

@get('/')
@view('jobs')
@requires_auth
def index():
    return dict(ctx=getctx())

@get('/jobs')
@view('jobstable')
@requires_auth
def jobs():
    c = getcursor()
    c.execute("""
        select j.computername
        , j.computeruser
        , j.script
        , ( select max(datestarted)
            from jobhistory
            where computername=j.computername
                and computeruser=j.computeruser
                and script=j.script
                and status='OK'
          ) as lastsuccess
        , ( select max(datestarted)
            from jobhistory
            where computername=j.computername
                and computeruser=j.computeruser
                and script=j.script
                and status='FAIL'
          ) as lastfail
        , ( select status
            from jobhistory
            where computername=j.computername
                and computeruser=j.computeruser
                and script=j.script
            order by datestarted desc
            limit 1
          ) as laststatus
        , ( select datefinished-datestarted
            from jobhistory
            where computername=j.computername
                and computeruser=j.computeruser
                and script=j.script
            order by datestarted desc
            limit 1
          ) as lastduration
        from jobhistory as j
        group by j.computername, j.computeruser, j.script
        order by j.computername, j.computeruser, j.script ;
    """)
    jobs = []
    for job in c:
        j = dict(job)
        j['lastsuccess'] = timestamp_to_show(j['lastsuccess'])
        j['lastfail'] = timestamp_to_show(j['lastfail'])
        j['lastduration'] = "%.3f" % j['lastduration']
        jobs.append(j)
    return dict(jobs=jobs)

@post('/jobs')
def newjob():
    start_time = request.forms.start_time
    end_time = request.forms.end_time
    status = request.forms.status
    script = request.forms.script
    output = request.forms.output.encode('utf-8')
    computername = request.forms.computername
    computeruser = request.forms.username
    ip = request.remote_addr
    rid = request.forms.id
    log.info('new job status from %s@%s/%s (%s)', computeruser, computername,
        script, ip)
    log.info('  id: %s', rid)
    if not re.match(r'^[a-f0-9-]{36}$', rid):
        raise ValueError('invalid rid')
    with open(config['dbname'] + '.logs/' + rid, 'w') as fp:
        fp.write(output)
    try:
        with db_trans() as c:
            c.execute("insert into jobhistory (id, script, computername, "
                "ip, computeruser, datestarted, datefinished, "
                "status) values (:rid, :script, :computername, :ip, "
                ":computeruser, :start_time, :end_time, :status)",
                locals())
    except sqlite3.IntegrityError:
        # Ignoring duplicate insertion.
        return 'ok'
    else:
        return 'ok'

# Delete login sessions older than 7 days
def purge_sessions():
    with db_trans() as c:
        c.execute("delete from sessions where julianday('now') - "
            "julianday(date_login) > 7")
        if c.rowcount > 0:
            log.info('maint_thread: purged %s login sessions', c.rowcount)

# Delete output files from clogd.db.log that are not referenced
# on database.
def purge_logs():
    path = config['dbname'] + '.logs'
    c = getcursor()
    for out in os.listdir(path):
        c.execute("select count(*) from jobhistory where id=:out", locals())
        r = c.fetchone()[0]
        if r == 0:
            log.debug('maint_thread: removing stale log %s', out)
            os.unlink(os.path.join(path, out))

# Long running maintenance thread.
def maint_thread():
    log.info('maint_thread: starting maintenance thread')
    while True:
        log.info('maint_thread: starting maintenance')
        purge_logs()
        purge_sessions()
        log.info('maint_thread: finishing maintenance')
        time.sleep(1800)


if __name__ == '__main__':

    parser = argparse.ArgumentParser()

    parser.add_argument('--host', help='host to listen for connections',
        default='127.0.0.1')
    parser.add_argument('--port', help='port to listen for connections',
        default=7890, type=int)
    parser.add_argument('--debug', help='run clogd in debug mode',
        default=False, action='store_true')

    args = parser.parse_args()

    # Starting maintenance thread
    t = threading.Thread(target=maint_thread)
    t.daemon = True
    t.start()

    log.info('starting clogd %s on %s:%d', __VERSION__, args.host, args.port)
    run(host=args.host, port=args.port, debug=args.debug,
        server='waitress', reloader=args.debug)
