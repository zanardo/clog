#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
#
# Copyright (c) 2013, Antonio Zanardo <zanardo@gmail.com>
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# This is clog server. See https://github.com/zanardo/clog for more details.
#

__VERSION__ = '0.1dev'

from bottle import run, local, route, view, get, post, redirect, \
	response, request, static_file
from contextlib import contextmanager

import threading, sqlite3, os, re, datetime, os.path, argparse, logging

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s.%(msecs)03d '
	'%(levelname)3s | %(message)s', datefmt='%Y/%m/%d %H:%M:%S')
log = logging.getLogger(__name__)

config = {}
config['dbname'] = 'clogd.db'

def getctx():
	return dict(version=__VERSION__)

def getdb():
    # Return a database connection handle per thread
    if not hasattr(local, 'db'):
        local.db = sqlite3.connect(config['dbname'],
                                   detect_types=sqlite3.PARSE_DECLTYPES)
        # Access results via dict() by column name
        local.db.row_factory = sqlite3.Row
    return local.db

def getcursor():
    # Return a new cursor for database access
    return getdb().cursor()

@contextmanager
def db_trans():
	# Open a new database transaction and commit on context
	# exit, or rollback in case anything fails.
    dbh = getdb()
    c = dbh.cursor()
    try:
        yield c     # New cursor
    except:
        dbh.rollback()
        raise
    finally:
        dbh.commit()

def timestamp_to_show(timestamp):
	if timestamp:
		return datetime.datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')
	else:
		return '-'

@route('/static/:filename')
def static(filename):
    assert re.match(r'^[\w\d\-]+\.[\w\d\-]+$', filename)
    return static_file('static/%s' % filename, root='.')

@get('/job/<id>')
def joboutput(id):
	if not re.match(r'^[a-f0-9-]{36}$', id):
		raise ValueError('invalid id')
	output = ''
	with open(os.path.join('clogd.db.logs', id), 'r') as fp:
		output = fp.read()
	response.content_type = 'text/plain'
	return output

@get('/jobs/<computername>/<computeruser>/<script>/')
@view('history')
def jobhistory(computername, computeruser, script):
	c = getcursor()
	c.execute("select id, computername, computeruser, script, "
		"datestarted, datefinished, status, datefinished-datestarted as duration "
		"from jobhistory "
		"where computername=:computername "
		"  and computeruser=:computeruser "
		"  and script=:script "
		"order by computername, computeruser, script, datestarted desc", (locals()))
	history = []
	for hist in c:
		h = dict(hist)
		h['datestarted'] = timestamp_to_show(h['datestarted'])
		h['datefinished'] = timestamp_to_show(h['datefinished'])
		h['duration'] = "%.3f" % h['duration']
		history.append(h)
	return dict(history=history, ctx=getctx())

@get('/')
@view('jobs')
def index():
	return dict(ctx=getctx())

@get('/jobs')
@view('jobstable')
def jobs():
	c = getcursor()
	c.execute("""
		select j.computername
		, j.computeruser
		, j.script
		, ( select max(datestarted)
			from jobhistory
			where computername=j.computername
				and computeruser=j.computeruser
				and script=j.script
				and status='OK'
		  ) as lastsuccess
		, ( select max(datestarted)
			from jobhistory
			where computername=j.computername
				and computeruser=j.computeruser
				and script=j.script
				and status='FAIL'
		  ) as lastfail
		, ( select status
			from jobhistory
			where computername=j.computername
				and computeruser=j.computeruser
				and script=j.script
			order by datestarted desc
			limit 1
		  ) as laststatus
		, ( select datefinished-datestarted
			from jobhistory
			where computername=j.computername
				and computeruser=j.computeruser
				and script=j.script
			order by datestarted desc
			limit 1
		  ) as lastduration
		from jobhistory as j
		group by j.computername, j.computeruser, j.script
		order by j.computername, j.computeruser, j.script ;
	""")
	jobs = []
	for job in c:
		j = dict(job)
		j['lastsuccess'] = timestamp_to_show(j['lastsuccess'])
		j['lastfail'] = timestamp_to_show(j['lastfail'])
		j['lastduration'] = "%.3f" % j['lastduration']
		jobs.append(j)
	return dict(jobs=jobs)

@post('/jobs')
def newjob():
	start_time = request.forms.start_time
	end_time = request.forms.end_time
	status = request.forms.status
	script = request.forms.script
	output = request.forms.output.encode('utf-8')
	computername = request.forms.computername
	computeruser = request.forms.username
	ip = request.remote_addr
	rid = request.forms.id
	log.info('new job status from %s@%s/%s (%s)', computeruser, computername,
		script, ip)
	log.info('  id: %s', rid)
	if not re.match(r'^[a-f0-9-]{36}$', rid):
		raise ValueError('invalid rid')
	with open(config['dbname'] + '.logs/' + rid, 'w') as fp:
		fp.write(output)
	try:
		with db_trans() as c:
			c.execute("insert into jobhistory (id, script, computername, "
				"ip, computeruser, datestarted, datefinished, "
				"status) values (:rid, :script, :computername, :ip, "
				":computeruser, :start_time, :end_time, :status)",
				locals())
	except sqlite3.IntegrityError:
		# Ignoring duplicate insertion.
		return 'ok'
	else:
		return 'ok'


if __name__ == '__main__':

	parser = argparse.ArgumentParser()

	parser.add_argument('--host', help='host to listen for connections',
		default='127.0.0.1')
	parser.add_argument('--port', help='port to listen for connections',
		default=7890, type=int)
	parser.add_argument('--debug', help='run clogd in debug mode',
		default=False, action='store_true')

	args = parser.parse_args()

	log.info('starting clogd %s on %s:%d', __VERSION__, args.host, args.port)
	run(host=args.host, port=args.port, debug=args.debug,
	    server='waitress', reloader=args.debug)