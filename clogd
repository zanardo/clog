#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
#
# Copyright (c) 2013-2014, Antonio Zanardo <zanardo@gmail.com>
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# This is clog server. See https://github.com/zanardo/clog for more details.
#

__VERSION__ = '0.5dev'

from bottle import run, local, route, view, get, post, redirect, \
    response, request, static_file, abort
from contextlib import contextmanager
from functools import wraps
from hashlib import sha1
from uuid import uuid4

import threading, sqlite3, re, datetime, argparse, logging, \
    random, bottle, time, subprocess, zlib, traceback, base64

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s.%(msecs)03d '
    '%(levelname)3s | %(message)s', datefmt='%Y/%m/%d %H:%M:%S')
log = logging.getLogger(__name__)

# schema version
SCHEMA = 1

CONFIG = {}
CONFIG['dbname'] = 'clogd.db'

# Bottle has a low limit for post data. Let's make it larger.
bottle.BaseRequest.MEMFILE_MAX = 10 * 1024 * 1024

def duration_to_human(seconds):
    if seconds < 1:
        return '%d ms' % (seconds*1000.0)
    if seconds < 60:
        return '%d sec' % seconds
    if seconds < 3600:  # 1 hour
        return '%d min %d sec' % (seconds/60.0, seconds%60)
    return '%d hr %d min' % (seconds/3600, (seconds/3600%60))

def timediff_to_human(seconds):
    if seconds is None:
        return ''
    diff = (datetime.datetime.now()-seconds).total_seconds()
    if diff < 1:
        return '%d ms' % (diff*1000.0)
    if diff < 60:
        return '%d sec' % diff
    if diff < 3600: # 1 hour
        return '%d min' % (diff/60)
    if diff < 86400:    # 1 day
        return '%d hr' % (diff/3600)
    if diff < 2419200:  # 1 month
        return '%d days' % (diff/86400)
    if diff < 29030400: # 1 year
        return '%d mo' % (diff/2419200)
    return 'ages'

def getctx():
    user = currentuser()
    user_is_admin = userisadmin(user)
    return dict(version=__VERSION__, username=user, isadmin=user_is_admin)

def getdb():
    # Return a database connection handle per thread
    if not hasattr(local, 'db'):
        local.db = sqlite3.connect(CONFIG['dbname'],
                                   detect_types=sqlite3.PARSE_DECLTYPES)
        # Access results via dict() by column name
        local.db.row_factory = sqlite3.Row
        local.db.text_factory = str
        c = local.db.cursor()
        c.execute("PRAGMA foreign_keys = ON;")
        c.execute("PRAGMA synchronous = NORMAL;")
        c.execute("PRAGMA journal_mode = WAL;")
        c.execute("PRAGMA busy_timeout = 200;")
        # Migrate database schema version if needed.
        DatabaseSchemaMigration(local.db, SCHEMA)
    return local.db

def getcursor():
    # Return a new cursor for database access
    return getdb().cursor()

@contextmanager
def db_trans():
    # Open a new database transaction and commit on context exit, or rollback in
    # case anything fails. Dispose the cursor on finish.
    dbh = getdb()
    c = dbh.cursor()
    try:
        yield c     # New cursor
    except:
        dbh.rollback()
        raise
    else:
        dbh.commit()
    finally:
        c.close()

class DatabaseSchemaMigration(object):
    """
    Migrate schema versions from database. Versions are stored in
    PRAGMA user_version on the SQLite database, and checked on getdb()
    """
    def __init__(self, db_conn, destination_version):
        self.db_conn = db_conn
        self.destination_version = destination_version
        self.current_schema_version = self._get_version()
        if self.current_schema_version < self.destination_version:
            self._migrate(db_conn, destination_version)

    def _get_version(self):
        """
        Fetch the current schema version from database.
        """
        c = self.db_conn.cursor()
        c.execute("PRAGMA user_version")
        return int(c.fetchone()[0])

    def _migrate(self, db_conn, destination_version):
        """
        Migrate the schema on database with connection db_conn to
        destination_version.
        """
        c = self.db_conn.cursor()
        try:
            log.info("starting schema migration from %d to %d",
                self.current_schema_version, self.destination_version)
            if self.current_schema_version == 0:
                log.info("applying schema 1 modifications")
                c.executescript("""
                    CREATE TABLE jobs (
                        id integer not null primary key,
                        computername text not null,
                        computeruser text not null,
                        script text not null,
                        date_last_success timestamp,
                        date_last_failure timestamp,
                        last_status text,
                        last_duration float
                    );
                    CREATE UNIQUE INDEX idx_jobs_job ON jobs(computername,
                        computeruser, script);
                """)
                c.execute("insert into jobs (computername, computeruser, script)"
                    "select computername, computeruser, script from jobhistory "
                    "group by computername, computeruser, script")
                # filling date_last_success
                c.execute("select computername, computeruser, script, "
                    "max(datestarted) as date from jobhistory where "
                    "status='ok' group by computername, computeruser, script")
                c2 = getcursor()
                for r in c:
                    date = r['date']
                    computername = r['computername']
                    computeruser = r['computeruser']
                    script = r['script']
                    c2.execute("update jobs set date_last_success=:date where "
                        "computername=:computername and computeruser=:computeruser "
                        "and script=:script", locals())
                # filling date_last_failure
                c.execute("select computername, computeruser, script, "
                    "max(datestarted) as date from jobhistory where status='fail' "
                    "group by computername, computeruser, script")
                c2 = getcursor()
                for r in c:
                    date = r['date']
                    computername = r['computername']
                    computeruser = r['computeruser']
                    script = r['script']
                    c2.execute("update jobs set date_last_failure=:date where "
                        "computername=:computername and computeruser=:computeruser "
                        "and script=:script", locals())
                # filling last_status and last_duration
                c.execute("select computername, computeruser, script, status, "
                    "duration from jobhistory group by computername, computeruser, "
                    "script having max(datestarted)")
                c2 = getcursor()
                for r in c:
                    computername = r['computername']
                    computeruser = r['computeruser']
                    script = r['script']
                    status = r['status']
                    duration = r['duration']
                    c2.execute("update jobs set last_status=:status, "
                        "last_duration=:duration where computername=:computername "
                        "and computeruser=:computeruser and script=:script",
                        locals())
                # changing jobhistory
                c.executescript("""
                    CREATE TABLE jobhistory2 (
                        id text not null primary key,
                        job_id integer not null references jobs(id),
                        ip text not null,
                        datestarted timestamp not null,
                        datefinished timestamp not null,
                        duration float not null,
                        status text not null,
                        output blob
                    );
                """)
                c.execute("insert into jobhistory2 (id, job_id, ip, datestarted, "
                    "datefinished, duration, status, output) select j1.id, j2.id, "
                    "ip, datestarted, datefinished, duration, status, output "
                    "from jobhistory as j1 inner join jobs as j2 on "
                    "j2.computername=j1.computername and "
                    "j2.computeruser=j1.computeruser and j2.script=j1.script")
                c.execute("drop table jobhistory")
                c.execute("alter table jobhistory2 rename to jobhistory")
                # changing jobconfig
                c.executescript("""
                    CREATE TABLE jobconfig2 (
                        job_id integer not null references jobs(id) primary key,
                        daystokeep int not null
                    );
                """)
                c.execute("insert into jobconfig2 (job_id, daystokeep) select "
                    "j2.id, j1.daystokeep from jobconfig as j1 inner join jobs "
                    "as j2 on j2.computername=j1.computername and "
                    "j2.computeruser=j1.computeruser and j2.script=j1.script")
                c.execute("drop table jobconfig")
                c.execute("alter table jobconfig2 rename to jobconfig")
                # changing jobconfigalert
                c.executescript("""
                    CREATE TABLE jobconfigalert2 (
                        job_id integer not null references jobs(id),
                        email text not null,
                        PRIMARY KEY(job_id, email)
                    );
                """)
                c.execute("insert into jobconfigalert2 (job_id, email) select "
                    "j2.id, j1.email from jobconfigalert as j1 inner join jobs "
                    "as j2 on j2.computername=j1.computername and "
                    "j2.computeruser=j1.computeruser and j2.script=j1.script")
                c.execute("drop table jobconfigalert")
                c.execute("alter table jobconfigalert2 rename to jobconfigalert")
                c.execute("create index idx_jobhistory_datestarted on jobhistory "
                    "(datestarted desc)")
                # increasing schema version
                c.execute("PRAGMA user_version=1;")
        except Exception as ex:
            self.db_conn.rollback()
            raise
        else:
            self.db_conn.commit()
        finally:
            c.close()
        log.info("schema migration successful")

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        session_id = request.get_cookie('clog')
        if not session_id or not validatesession(session_id):
            return redirect('/login')
        return f(*args, **kwargs)
    return decorated

def requires_admin(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        session_id = request.get_cookie('clog')
        if not session_id or not validatesession(session_id) or \
                not userisadmin(currentuser()):
            return 'not authorized'
        return f(*args, **kwargs)
    return decorated

def validateuserdb(user, passwd):
    passwdsha1 = sha1(passwd).hexdigest()
    c = getcursor()
    c.execute("select username from users where username = :user "
        "and password = :passwdsha1", locals())
    r = c.fetchone()
    return bool(r)

def validatesession(session_id):
    c = getcursor()
    c.execute("select session_id from sessions where session_id = :session_id",
        locals())
    r = c.fetchone()
    return bool(r)

def currentuser():
    session_id = request.get_cookie('clog')
    c = getcursor()
    c.execute("select username from sessions "
        "where session_id = :session_id", locals())
    return c.fetchone()['username']

def userisadmin(username):
    c = getcursor()
    c.execute("select is_admin from users where username = :username",
        locals())
    return c.fetchone()['is_admin']

def removesession(session_id):
    with db_trans() as c:
        c.execute("delete from sessions where session_id = :session_id",
            locals())

def makesession(user):
    with db_trans() as c:
        session_id = str(uuid4())
        c.execute("insert into sessions (session_id, username) "
            "values (:session_id, :user)", locals())
    return session_id

def get_job_id(computername, computeruser, script):
    c = getcursor()
    c.execute("select id from jobs where computername=:computername "
        "and computeruser=:computeruser and script=:script", locals())
    r = c.fetchone()
    if not r:
        return None
    else:
        return r[0]

@get('/admin')
@view('admin')
@requires_auth
@requires_admin
def admin():
    c = getcursor()
    c.execute("select username, is_admin from users "
        "order by username")
    users = []
    for user in c:
        user = dict(user)
        users.append(user)
    return dict(ctx=getctx(), users=users)

@get('/admin/remove-user/:username')
@requires_auth
@requires_admin
def removeuser(username):
    if username == currentuser():
        return 'cant remove current user!'
    with db_trans() as c:
        c.execute("delete from users where username = :username", locals())
    return redirect('/admin')

@post('/admin/save-new-user')
@requires_auth
@requires_admin
def newuser():
    username = request.forms.username
    if username.strip() == '':
        return 'invalid user!'
    password = str(int(random.random() * 999999))
    sha1password = sha1(password).hexdigest()
    with db_trans() as c:
        c.execute("insert into users (username, password, is_admin ) "
            "values (:username, :sha1password, 0)", locals())
    return u'user %s created with password %s' % (username, password)

@get('/admin/force-new-password/:username')
@requires_auth
@requires_admin
def forceuserpassword(username):
    password = str(int(random.random() * 999999))
    sha1password = sha1(password).hexdigest()
    if username == currentuser():
        return 'cant change password for current user!'
    with db_trans() as c:
        c.execute("update users set password = :sha1password "
            "where username = :username", locals())
    return u'user %s had password changed to: %s' % (username, password)

@get('/admin/change-user-admin-status/:username/:status')
@requires_auth
@requires_admin
def changeuseradminstatus(username, status):
    if username == currentuser():
        return 'cant change admin status for current user!'
    if not status in ('0', '1'):
        abort(400, "invalid status")
    with db_trans() as c:
        c.execute("update users set is_admin = :status "
            "where username = :username", locals())
    return redirect('/admin')

@get('/login')
@view('login')
def login():
    return dict(version=__VERSION__)

@post('/login')
def validatelogin():
    user = request.forms.user
    passwd = request.forms.passwd
    if validateuserdb(user, passwd):
        session_id = makesession(user)
        response.set_cookie('clog', session_id)
        return redirect('/')
    else:
        return 'invalid user or password'

@get('/logout')
def logout():
    session_id = request.get_cookie('clog')
    if session_id:
        removesession(session_id)
        response.delete_cookie('clog')
    return redirect('/login')

@get('/change-password')
@view('change-password')
@requires_auth
def changepassword():
    return dict(ctx=getctx())

@post('/change-password')
@requires_auth
def changepasswordsave():
    oldpasswd = request.forms.oldpasswd
    newpasswd = request.forms.newpasswd
    newpasswd2 = request.forms.newpasswd2
    username = currentuser()
    if not validateuserdb(username, oldpasswd):
        return 'invalid current password!'
    if newpasswd.strip() == '' or newpasswd2.strip() == '':
        return 'invalid new password!'
    if newpasswd != newpasswd2:
        return 'new passwords do not match!'
    passwdsha1 = sha1(newpasswd).hexdigest()
    with db_trans() as c:
        c.execute("update users set password = :passwdsha1 "
            "where username = :username", locals())
    return redirect('/')

@route('/static/:filename')
def static(filename):
    if not re.match(r'^[\w\d\-]+\.[\w\d\-]+$', filename):
        abort(400, "invalid filename")
    return static_file('static/%s' % filename, root='.')

@get('/jobs/<computername>/<computeruser>/<script>/<id>')
@requires_auth
def joboutput(computername, computeruser, script, id):
    if not re.match(r'^[a-f0-9-]{36}$', id):
        raise ValueError('invalid id')
    output = ''
    c = getcursor()
    c.execute("select h.output from jobhistory as h inner join jobs as j "
        "on h.job_id=j.id where j.computername=:computername and "
        "j.computeruser=:computeruser and j.script=:script and h.id=:id",
        locals())
    r = c.fetchone()
    if not r:
        response.status = 404
        return 'not found'
    else:
        response.content_type = 'text/plain'
        return zlib.decompress(r['output'])

@get('/jobs/<computername>/<computeruser>/<script>/')
@view('history')
@requires_auth
def jobhistory(computername, computeruser, script):
    ctx = getctx()
    ctx['computername'] = computername
    ctx['computeruser'] = computeruser
    ctx['script'] = script
    c = getcursor()
    c.execute("select h.id, j.computername, j.computeruser, j.script, "
        "h.datestarted, h.datefinished, h.status, h.duration "
        "from jobhistory as h inner join jobs as j on j.id=h.job_id "
        "where j.computername=:computername and j.computeruser=:computeruser "
        "and j.script=:script order by j.computername, j.computeruser, "
        "j.script, h.datestarted desc", locals())
    history = []
    for hist in c:
        h = dict(hist)
        h['duration'] = duration_to_human(h['duration'])
        history.append(h)
    return dict(history=history, ctx=ctx)

@get('/history')
@view('historytable')
@requires_auth
def allhistory():
    offset = 0
    if 'offset' in request.query:
        if re.match(r'^\d+$', request.query.offset):
            offset = int(request.query.offset)*25
    c = getcursor()
    c.execute("select h.id, j.computername, j.computeruser, j.script, "
        "h.datestarted, h.datefinished, h.status, h.duration "
        "from jobhistory as h inner join jobs as j on j.id=h.job_id "
        "order by h.datestarted desc limit 25 offset :offset", locals())
    history = []
    for hist in c:
        h = dict(hist)
        h['duration'] = duration_to_human(h['duration'])
        history.append(h)
    return dict(history=history, offset=offset)

@get('/config-job/<computername>/<computeruser>/<script>/')
@view('config-job')
@requires_auth
@requires_admin
def configjob(computername, computeruser, script):
    ctx = getctx()
    ctx['computername'] = computername
    ctx['computeruser'] = computeruser
    ctx['script'] = script
    daystokeep = 30
    c = getcursor()
    c.execute("select c.daystokeep from jobconfig as c inner join "
        "jobs as j on j.id=c.job_id where j.computername=:computername and "
        "j.computeruser=:computeruser and j.script=:script", locals())
    r = c.fetchone()
    if r:
        daystokeep = r['daystokeep']
    c.execute("select a.email from jobconfigalert as a inner join "
        "jobs as j on j.id=a.job_id where j.computername=:computername and "
        "j.computeruser=:computeruser and j.script=:script", locals())
    emails = []
    for r in c:
        emails.append(r['email'])
    return dict(ctx=ctx, daystokeep=daystokeep, emails="\n".join(emails))

@post('/purge-job/<computername>/<computeruser>/<script>/')
@requires_auth
@requires_admin
def purgejob(computername, computeruser, script):
    job_id = get_job_id(computername, computeruser, script)
    with db_trans() as c:
        c.execute("delete from jobhistory where job_id=:job_id", locals())
        c.execute("delete from jobconfig where job_id=:job_id", locals())
        c.execute("delete from jobconfigalert where job_id=:job_id", locals())
        c.execute("delete from jobs where id=:job_id", locals())
    return redirect('/')

@post('/save-daystokeep/<computername>/<computeruser>/<script>/')
@requires_auth
@requires_admin
def savedaystokeep(computername, computeruser, script):
    daystokeep = request.forms.daystokeep
    if not re.match(r'^\d+$', daystokeep):
        abort(400, "invalid days to keep")
    daystokeep = int(daystokeep)
    if daystokeep < 0:
        return 'days to keep must be >= 0'
    job_id = get_job_id(computername, computeruser, script)
    with db_trans() as c:
        c.execute("replace into jobconfig (job_id, daystokeep) "
            "values (:job_id, :daystokeep)", locals())
    return redirect('/config-job/' + computername + '/' +
        computeruser + '/' + script + '/')

@post('/save-alertemails/<computername>/<computeruser>/<script>/')
@requires_auth
@requires_admin
def savealertemails(computername, computeruser, script):
    job_id = get_job_id(computername, computeruser, script)
    with db_trans() as c:
        c.execute("delete from jobconfigalert where job_id=:job_id", locals())
        for email in request.forms.emails.split():
            c.execute("insert into jobconfigalert values (:job_id, :email)",
                locals())
    return redirect('/config-job/' + computername + '/' +
        computeruser + '/' + script + '/')

@get('/')
@view('jobs')
@requires_auth
def index():
    return dict(ctx=getctx())

@get('/jobs')
@view('jobstable')
@requires_auth
def jobs():
    c = getcursor()
    c.execute("select computername, computeruser, script, "
        "date_last_success, date_last_failure, last_status, "
        "last_duration from jobs order by computername, computeruser, "
        "script")
    jobs = []
    for job in c:
        j = dict(job)
        j['date_last_success'] = timediff_to_human(j['date_last_success'])
        j['date_last_failure'] = timediff_to_human(j['date_last_failure'])
        j['last_duration'] = duration_to_human(j['last_duration'])
        jobs.append(j)
    return dict(jobs=jobs)

@post('/')
def newjob():
    rid_regexp = r'^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'
    rid = request.forms.id
    if not re.match(rid_regexp, rid):
        abort(400, "invalid job id")

    start_time = request.forms.start_time
    if not re.match(r'^[\d+\.]+$', start_time):
        abort(400, "invalid start time")
    start_time = datetime.datetime.fromtimestamp(int(float(start_time)))

    end_time = request.forms.end_time
    if not re.match(r'^[\d+\.]+$', end_time):
        abort(400, "invalid end time")
    end_time = datetime.datetime.fromtimestamp(int(float(end_time)))

    duration = request.forms.duration
    if not re.match(r'^[0-9\.]+$', duration):
        abort(400, "invalid duration")

    status = request.forms.status
    if not status in ('fail', 'ok'):
        abort(400, "invalid status")

    script = request.forms.script
    if not re.match(r'^[a-zA-Z0-9\-_\.]+$', script):
        abort(400, "invalid script name")

    output = request.forms.output or ''
    output = base64.b64decode(output)
    outputz = buffer(zlib.compress(output))

    computername = request.forms.computername
    computeruser = request.forms.username

    # Windows
    if '\\' in computeruser:
        computeruser = computeruser.split('\\')[-1]

    ip = request.remote_addr

    log.info('new job status from %s@%s/%s (%s)', computeruser, computername,
        script, ip)
    log.info('  id: %s', rid)

    job_id = get_job_id(computername, computeruser, script)
    if not job_id:
        with db_trans() as c:
            c.execute("insert into jobs (computername, computeruser, "
                "script, last_status, last_duration) values "
                "(:computername, :computeruser, :script, :status, :duration)",
                locals())
            job_id = c.lastrowid
    try:
        with db_trans() as c:
            c.execute("insert into jobhistory (id, job_id, ip, "
                "datestarted, datefinished, status, duration, output) "
                "values (:rid, :job_id, :ip, :start_time, :end_time, :status, "
                ":duration, :outputz)", locals())
            if status == 'ok':
                c.execute("update jobs set date_last_success=:start_time, "
                    "last_status='ok' where id=:job_id", locals())
            else:
                c.execute("update jobs set date_last_failure=:start_time, "
                    "last_status='fail' where id=:job_id", locals())
    except sqlite3.IntegrityError:
        # Ignoring duplicate insertion.
        return 'ok'
    else:
        emails = getalertemails(computername, computeruser, script)
        if emails:
            if status == 'fail':
                for email in emails:
                    log.info("  job failed, sending alert to %s", email)
                    send_alert(email, computername, computeruser, script,
                        status, output)
            elif status == 'ok':
                c = getcursor()
                c.execute("select status from jobhistory where job_id=:job_id "
                    "order by datestarted desc limit 1 offset 1", locals())
                r = c.fetchone()
                if r and r['status'] == 'fail':
                    for email in emails:
                        log.info("  job ok, sending alert to %s", email)
                        send_alert(email, computername, computeruser, script,
                            status, output)
        return 'ok'

# Get notification e-mails for a job.
def getalertemails(computername, computeruser, script):
    job_id = get_job_id(computername, computeruser, script)
    c = getcursor()
    c.execute("select email from jobconfigalert where job_id=:job_id",
        locals())
    emails = []
    for row in c:
        emails.append(row['email'])
    return emails

# Delete login sessions older than 7 days
def purge_sessions():
    with db_trans() as c:
        c.execute("delete from sessions where julianday('now') - "
            "julianday(date_login) > 7")
        if c.rowcount > 0:
            log.info('maint_thread: purged %s login sessions', c.rowcount)

# Delete old entries on jobhistory from database.
def purge_jobhistory():
    c = getcursor()
    c.execute("select id from jobs")
    for job in c:
        job_id = job['id']
        c2 = getcursor()
        c2.execute("select daystokeep from jobconfig where job_id=:job_id",
            locals())
        daystokeep = 30
        r = c2.fetchone()
        if r:
            daystokeep = r['daystokeep']
        with db_trans() as c3:
            c3.execute("delete from jobhistory where "
                "julianday('now')-julianday(datestarted) > :daystokeep and "
                "job_id=:job_id", locals())
            if c3.rowcount > 0:
                log.debug("maint_thread: purged %s entries for jobhistory",
                    c3.rowcount)

def send_alert(email, computername, computeruser, script, status, output):
    subject = ''
    body = ''
    if status == 'fail':
        subject = 'clog: job {} failed for {}@{}'.format(script, computeruser,
            computername)
        body = output
    elif status == 'ok':
        subject = 'clog: job {} back to normal for {}@{}'.format(script,
            computeruser, computername)
    body += '\n\nThis is an automatic notification sent by ' + \
            'clog (https://github.com/zanardo/clog)'
    s = subprocess.Popen(['mail', '-s', subject, email], stdin=subprocess.PIPE)
    s.communicate(body)

# Long running maintenance thread.
def maint_thread():
    log.info('maint_thread: starting maintenance thread')
    while True:
        time.sleep(1800)
        log.info('maint_thread: starting maintenance')
        try:
            purge_jobhistory()
            purge_sessions()
        except Exception, ex:
            log.info("maint_thread: error: %s", ex)
            print traceback.format_exc()
        log.info('maint_thread: finishing maintenance')


if __name__ == '__main__':

    parser = argparse.ArgumentParser()

    parser.add_argument('--host', help='host to listen for connections',
        default='0.0.0.0')
    parser.add_argument('--port', help='port to listen for connections',
        default=7890, type=int)
    parser.add_argument('--debug', help='run clogd in debug mode',
        default=False, action='store_true')

    args = parser.parse_args()

    # Force start database connection so schema migration can be started.
    getcursor()

    # Starting maintenance thread
    t = threading.Thread(target=maint_thread)
    t.daemon = True
    t.start()

    log.info('starting clogd %s on %s:%d', __VERSION__, args.host, args.port)
    run(host=args.host, port=args.port, debug=args.debug,
        server='waitress', reloader=args.debug)
