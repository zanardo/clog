#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
#
# Copyright (c) 2013, Antonio Zanardo <zanardo@gmail.com>
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# This is clog server. See https://github.com/zanardo/clog for more details.
#

from flask import Flask, request, render_template, send_file
from contextlib import contextmanager

import threading
import sqlite3
import os
import re
import datetime
import os.path

app = Flask(__name__)
local = threading.local()
config = {}
config['dbname'] = 'clog.db'

def getdb():
    if not hasattr(local, 'db'):
        local.db = sqlite3.connect(config['dbname'])
        local.db.row_factory = sqlite3.Row
    return local.db

def getcursor():
    return getdb().cursor()

@contextmanager
def db_trans():
    dbh = getdb()
    c = dbh.cursor()
    try:
        yield c
    except:
        dbh.rollback()
        raise
    finally:
        dbh.commit()

def timestamp_to_show(timestamp):
	if timestamp:
		return datetime.datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')
	else:
		return '-'

@app.route('/job/<id>')
def joboutput(id):
	if not re.match(r'^[a-f0-9-]{36}$', id):
		raise ValueError('invalid id')
	return send_file(os.path.join('clog.db.logs', id), mimetype='text/plain')


@app.route('/jobs/<computername>/<computeruser>/<script>/', methods=['GET'])
def jobhistory(computername, computeruser, script):
	c = getcursor()
	c.execute("select id, computername, computeruser, script, "
		"datestarted, datefinished, status, datefinished-datestarted as duration "
		"from jobhistory "
		"where computername=:computername "
		"  and computeruser=:computeruser "
		"  and script=:script "
		"order by computername, computeruser, script, datestarted desc", (locals()))
	history = []
	for hist in c:
		h = dict(hist)
		h['datestarted'] = timestamp_to_show(h['datestarted'])
		h['datefinished'] = timestamp_to_show(h['datefinished'])
		h['duration'] = "%.3f" % h['duration']
		history.append(h)
	return render_template('history.html', history=history)

@app.route('/jobs', methods=['GET', 'POST'])
def jobs():
	if request.method == 'POST':
		start_time = request.form['start_time']
		end_time = request.form['end_time']
		status = request.form['status']
		script = request.form['script']
		output = request.form['output'].encode('utf-8')
		computername = request.form['computername']
		computeruser = request.form['username']
		ip = request.remote_addr
		rid = request.form['id']
		if not re.match(r'^[a-f0-9-]{36}$', rid):
			raise ValueError('invalid rid')
		with open(config['dbname'] + '.logs/' + rid, 'w') as fp:
			fp.write(output)
		with db_trans() as c:
			c.execute("insert into jobhistory (id, script, computername, "
				"ip, computeruser, datestarted, datefinished, "
				"status) values (:rid, :script, :computername, :ip, "
				":computeruser, :start_time, :end_time, :status)",
				locals())
		return 'ok'
	elif request.method == 'GET':
		c = getcursor()
		c.execute("""
			select j.computername
			, j.computeruser
			, j.script
			, ( select max(datestarted)
				from jobhistory
				where computername=j.computername
					and computeruser=j.computeruser
					and script=j.script
					and status='OK'
			  ) as lastsuccess
			, ( select max(datestarted)
				from jobhistory
				where computername=j.computername
					and computeruser=j.computeruser
					and script=j.script
					and status='FAIL'
			  ) as lastfail
			, ( select status
				from jobhistory
				where computername=j.computername
					and computeruser=j.computeruser
					and script=j.script
				order by datestarted desc
				limit 1
			  ) as laststatus
			, ( select datefinished-datestarted
				from jobhistory
				where computername=j.computername
					and computeruser=j.computeruser
					and script=j.script
				order by datestarted desc
				limit 1
			  ) as lastduration
			from jobhistory as j
			group by j.computername, j.computeruser, j.script
			order by j.computername, j.computeruser, j.script ;
		""")
		jobs = []
		for job in c:
			j = dict(job)
			j['lastsuccess'] = timestamp_to_show(j['lastsuccess'])
			j['lastfail'] = timestamp_to_show(j['lastfail'])
			j['lastduration'] = "%.3f" % j['lastduration']
			jobs.append(j)
		return render_template('jobs.html', jobs=jobs)

if __name__ == '__main__':
	if os.path.isfile('.dev'):
		app.debug = True
		app.run(host='127.0.0.1', port=7890)
	else:
		app.run(host='0.0.0.0', port=7890)